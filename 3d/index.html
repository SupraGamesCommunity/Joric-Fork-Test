<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Joric's Supraland 3D</title>
<style type="text/css">
html,body{margin:0px;height:100%;width:100%; font-family:sans-serif;}
.container{width:100%;height:100%}
</style>
<link rel="stylesheet" href="https://unpkg.com/maptalks/dist/maptalks.css">
<script type="text/javascript" src="https://unpkg.com/maptalks/dist/maptalks.min.js"></script>
<base href="../"></base>
<body>
<div id="map" class="container"></div>
<script>

let startPitch = 45;
let startZoom = 3;
let heightFactor = 0.25;
let drawAltitude = false;
let drawShadow = true;
let markerSymbol = markerSymbol2
let map = null;

let markerColors = ['#48a1c2','#f4bd76','#419869','#88cf78','#988','#877','#766','#e4e1d6'];
let lineColor = '#888';
let colors = {};
let items = {
  'Chest_C':'chest','BP_EngagementCup_Base_C':'trophy','Bones_C':'bones', 'Scrap_C':'scrap',
  //'EnemySpawn1_C':'grave_wood','EnemySpawn2_C':'grave_stone','EnemySpawn3_C':'grave_volcano',
  //'Coin_C':'coin'
  //'Jumppad_C':'map',
};

let bindings = {
  KeyA:['x',+1],KeyD:['x',-1],
  KeyW:['y',+1],KeyS:['y',-1],
  KeyQ:['b',+1],KeyE:['b',-1],
  KeyT:['z',+1],KeyG:['z',-1],
  KeyX:['p',+1],KeyZ:['p',-1],
};

let maps = {
  // data taken from the MapWorld* nodes
  'sl':  { 
      title: 'Supraland',
      "MapWorldCenter": { "X": 13000.0, "Y": -2000.0, "Z": 0.0 },
      "MapWorldSize": 175000.0,
      "MapWorldUpperLeft": { "X": -74500.0, "Y": -89500.0, "Z": 0.0 },
      "MapWorldLowerRight": { "X": 100500.0, "Y": 85500.0, "Z": 0.0 },
  },

  'slc': {
    title: 'Supraland Crash',
      "MapWorldCenter": { "X": 25991.0, "Y": -16.0, "Z": 0.0  },
      "MapWorldSize": 90112.0,
      "MapWorldUpperLeft": { "X": -19065.0, "Y": -45040.0, "Z": 0.0 },
      "MapWorldLowerRight": { "X": 71047.0, "Y": 45072.0, "Z": 0.0 },
  },

  'siu': {
      title: 'Supraland Six Inches Under',
      "MapWorldCenter": { "X": 0.0, "Y": -19000.0, "Z": 10000.0 },
      "MapWorldSize": 147456.0,
      "MapWorldUpperLeft": { "X": -73728.0, "Y": -92728.0, "Z": 10000.0 },
      "MapWorldLowerRight": { "X": 73728.0, "Y": 54728.0, "Z": 10000.0 },
  },
};

function markerSymbol1(o, shadow=false) {
  if (shadow) {
    return [
      {
        markerWidth: 32,
        markerHeight: 32,
        markerFill: '#000',
        markerType: 'ellipse',
      }
    ];
  }
  return [
    {
      markerFile: 'img/'+icon+'.png',
      markerWidth  : 32,
      markerHeight : 32,
    },
  ];
}

function markerSymbol2(o, shadow=false) {
  if (shadow) {
    return [
      {
        markerWidth: 75,
        markerHeight: 75,
        markerFill: '#000',
        markerType: 'pin',
      },
    ];
  }
  return [
    {
      markerWidth: 75,
      markerHeight: 75,
      markerFill: colors[icon],
      markerType: 'pin',
    },
    {
      markerFile: 'img/'+icon+'.png',
      markerWidth  : 32,
      markerHeight : 32,
      markerDy: -22,
    },
  ];
}

function loadMap(mapId) {
  location.hash = mapId;

  document.querySelector('#map').style.backgroundColor = mapId=='siu' ? '#141414' : '#000';

  if (map) {
    map.remove();
  }

  let p = maps[mapId];
  let mapSize = {width: 8192, height: 8192}
  let scale = p.MapWorldSize / mapSize.width;
  let [left,top,right,bottom] = [p.MapWorldUpperLeft.X, p.MapWorldUpperLeft.Y, p.MapWorldLowerRight.X, p.MapWorldLowerRight.Y];
  let extent = new maptalks.Extent(left, top, right, bottom);
  center = [p.MapWorldCenter.X, p.MapWorldCenter.Y];

  map = new maptalks.Map('map', {
    zoom: startZoom,
    pitch: startPitch,
    heightFactor: heightFactor,
    center: center,
    maxExtent: extent,
    maxPitch: 80,
    spatialReference : {
      projection : 'identity',
      resolutions : ( function() {
        const r = [];
        for (let i=32; i>0.125; i/=2) { r.push(i*scale); }
        return r;
      })(),
      fullExtent : { top: top, left: left, bottom: bottom, right: right },
    },
    baseLayer: new maptalks.TileLayer('base', {
      maxAvailableZoom: 4,
      urlTemplate: 'tiles/'+mapId+'/base/{z}/{x}/{y}.jpg',
      repeatWorld: false,
      tileSystem: [ 1, -1, left, top ],
      attribution: '<a href="https://github.com/joric/supraland" target="_blank">Joric\'s Supraland</a>',
    }),
    seamlessZoom: true,
    doubleClickZoom: true,
    zoomControl: {
      //position  : 'bottom-right',
      position  : 'top-right',
      zoomLevel : false,
    },
    compassControl: {
      //position: {right:20, bottom: 90},
      position  : 'bottom-right',
    },
  });

  let shadowLayer = new maptalks.VectorLayer('shadow', {
    enableAltitude: true,
    sortByDistanceToCamera: true,
    opacity: 0.25,
  }).addTo(map);

  let vectorLayer = new maptalks.VectorLayer('vector', {
    enableAltitude: true,
    sortByDistanceToCamera: true,
  }).addTo(map);

  if (drawAltitude) {
    vectorLayer.setOptions({
      drawAltitude : {
        lineWidth : 2,
        lineColor : '#888',
      },
    })
  }

  fetch('data/markers.'+mapId+'.json')
    .then((response) => response.json())
    .then((j) => {
      for (o of j) {
        if (! (o.lng>left && o.lng<right && o.lat>top && o.lat<bottom )) {
          continue;
        }
        if (icon = items[o.type]) {
          var marker = new maptalks.Marker([o.lng, o.lat, o.alt],{
            id: o.area+':'+o.name,
            properties: {name: o.name},
            symbol: markerSymbol(o),
          }).addTo(vectorLayer);

          new maptalks.ui.ToolTip(o.name,{}).addTo(marker);

          marker.setInfoWindow({
            title     : o.name,
            content   : JSON.stringify(o, null, 2).replaceAll('\n','<br>').replaceAll(' ','&nbsp;'),
            autoPan: true,
            autoCloseOn : 'click',
            dy: 22,
          });

          if (drawShadow) {
            new maptalks.Marker([o.lng, o.lat],{
              cursor: 'arrow',
              symbol: markerSymbol(o, true),
            })
            .addTo(shadowLayer);
          }

        }
      }
   });

  var toolbar = new maptalks.control.Toolbar({
    'position' : 'top-left',
    items: [
      { item : 'sl', click : function() { loadMap('sl'); }},
      { item : 'slc', click : function() { loadMap('slc'); }},
      { item : 'siu', click : function() { loadMap('siu'); }},
    ]
  }).addTo(map);

  function copyToClipboard(s) {
    let c = document.body.appendChild(document.createElement("input"));
    c.value = s;
    c.focus();
    c.select();
    document.execCommand('copy');
    c.parentNode.removeChild(c);
  }

  // context menu
  var options = {
    'items'  : [
      {
        item: 'Copy Map View URL',
        click: function () { let v = map.getView();
          copyToClipboard(window.location.href.replace(/#.*$/,'')+'#'+mapId+
            '/'+[v.center[0],v.center[1],v.zoom,v.pitch,v.bearing].join('/'));
        }
      },
      //'-',{item: 'item2', click: function () { alert('Click item2'); }}
    ]
  };
  map.setMenu(options);


  document.querySelector('.maptalks-compass').onclick = function(e) {
    if (map.getBearing()==0) {
      map.animateTo({ pitch: map.getPitch()==0 ? startPitch : 0 });
    }
  };

  //document.querySelector('.maptalks-compass').title = 'Click to reset (key R)';

  [].forEach.call(document.querySelectorAll('.maptalks-toolbar-hx > li'), function(div) {
    if (div.innerText==mapId) {
      div.style.background = '#6a97d9';
      div.style.color = '#fff';
    }
  });
}

window.onload = function(event) {
  mapId = Object.keys(maps).find(id=>location.hash.endsWith(id)) || 'sl';

  const ctx = document.createElement('canvas').getContext('2d',{ willReadFrequently: true });
  function getDominantColor(imageObject, amp) {
    ctx.drawImage(imageObject, 0, 0, 1, 1);
    const c = ctx.getImageData(0, 0, 1, 1).data;
    for (let i=0; i<3; i++) c[i] = Math.round(Math.min(255,c[i]*amp));
    return "#"+((1<<24)+(c[0]<<16)+(c[1]<<8)+c[2]).toString(16).slice(1);
  }

  for (key of Object.keys(items)) {
    const image = new Image();
    image.id = items[key];
    image.onload = function() {
      ctx.drawImage(image,0,0,100,100);
      colors[image.id] = getDominantColor(image, 1.5);
      if (Object.keys(items).length == Object.keys(colors).length) {
        loadMap(mapId);
      }
    };
    image.src = 'img/'+items[key]+'.png';
  }

  let flags = {};

  function update(timestep) {
    let step = 25;
    let v = {};
    for (key of Object.keys(bindings)) {
      if (flags[key]) {
        let [dir, step] = bindings[key];
        v[dir] = (v[dir]||0) + step;
      }
    }
    (v.x || v.y) && map.panBy([(v.x||0)*step, (v.y||0)*step], {duration: 1});
    v.b && map.setBearing(map.getBearing()+v.b*step/10);
    v.p && map.setPitch(map.getPitch()+v.p*step/10, {duration: 1});
    v.z && map.setZoom(map.getZoom()+v.z/16, {duration: 1});
    window.requestAnimationFrame(update);
  }

  window.addEventListener('keyup', (e) => {
    delete flags[e.code];
  });

  window.addEventListener("keydown",function (e) {
    if (e.code=='KeyF') {
      if (e.ctrlKey) {
        //searchControl.expand(true);
        //e.preventDefault();
      } else if (!e.target.id.startsWith('searchtext')) {
        //map.toggleFullscreen();
      }
    } else if(e.code=='KeyR') {
      if (map.getBearing()!=0) {
        map.animateTo({ bearing: 0 });
      } else {
        map.animateTo({ pitch: map.getPitch()==0 ? startPitch : 0 });
      }
    } else if(e.code=='KeyC') {
      map.panTo(center);
    }
    flags[e.code] = true;
  });

  window.requestAnimationFrame(update);
};

</script>
</body>
</html>

